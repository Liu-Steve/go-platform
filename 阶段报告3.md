# 阶段报告 3

## 一、本轮迭代完成的任务

### 前端

1. 完成了各个主要界面的编写，包括：
    + 主界面：显示当前玩家的id，可以选择加入房间或者创建房间
    + 加入房间界面：可以查询当前的房间列表，显示房间ID，房主用户名，当前人数等信息。还可以通过输入房间ID直接加入房间。
    + 创建房间界面：可以显示当前房间内的玩家用户名，并可以由房主选择黑白方。
    + 游戏界面：显示棋盘，棋子，房间信息，玩家信息，当前黑白棋等元素，可以进行下棋，停一手，认输，等操作
    + 游戏界面中的多个弹窗：包括加入房间弹窗，创建房间弹窗，游戏结束弹窗等
2. 完成了各个界面之间的跳转逻辑，例如：
    + 从主界面点击加入房间按钮，会弹出加入房间弹窗，输入房间号后或者在房间列表进行选择后，会跳转到游戏界面
    + 从主界面点击创建房间按钮，会跳转到游戏界面，并显示创建房间弹窗
    + 从游戏界面点击退出房间按钮，会跳转到主界面
    + 从游戏界面点击认输或者游戏结束，会弹出游戏结束弹窗
3. 与后端建立websocket，进行棋局的通信，例如：
    + 发送自己的下棋动作，接收对手的下棋动作，实时更新棋盘状态
    + 发送和接收停一手，认输等请求，根据用户的选择进行相应的处理
    + 接收后端的游戏结果判断，显示游戏结束弹窗，展示胜负结果和对局统计
4. 完成界面的美化，例如：
    + 使用了渐变色，阴影，圆角等效果，增加了视觉美感
    + 使用了动画，过渡，提示等效果，增加了交互体验
    + 使用了合适的字体，颜色，布局等效果，增加了信息可读性

### 后段业务部分

#### 系统模块

为了支持人机对战的功能，我们设计并实现了AI房间映射的机制，用于管理用户与AI的对战关系。我们将AI房间映射的接口与普通房间的接口进行了统一，使得在不影响原有功能的基础上，减少了代码的修改量，提高了开发效率。

#### 用户模块

为了解决房间销毁后用户状态不正确的问题，我们增加了一个自动修复的功能，当用户登录时，会自动将用户状态置为FREE，从而避免了用户无法加入或创建新的房间的情况，增强了系统的可用性。

#### 房间模块

为了实现人机对战的功能，我们新增了创建AI房间的接口，当用户选择人机对战时，会调用该接口，创建一个与AI绑定的房间，并将其存储在AI房间映射中。
我们还优化了退出房间的接口，使其能够适配AI房间和普通房间的不同情况，当用户退出房间时，会根据房间类型进行相应的处理，如销毁AI或释放资源等。

#### 下棋模块

为了增加人人对战的趣味性和灵活性，我们新增了停一手的功能，当用户执行停一手操作时，会向另一个用户发送一个通知，当双方都停一手时，会结束棋局，并调用AI来计算双方的目数，并将结果返回给前端显示。
为了适配人机对战的场景，我们也新增了人机对战时的停一手功能，当用户进行人机对战时，如果执行停一手操作，则AI会直接下一步棋，如果用户停一手后AI也停一手，则会计算对战结果并返回给前端显示。
我们还优化了下棋逻辑，修复了一些关于打劫、吃子等方面的bug，提高了下棋模块的稳定性和准确性。
我们还维护了最后落子位置的信息，每次用户落子成功后，会将最后落子位置存储并返回给前端，前端可以根据该信息来标记落子位置，提升用户体验。

#### AI模块

为了使用AI相关功能，我们新增了AI调用接口，通过远程调用模式来与AI进行交互。
我们完成了AI相关功能如初始化AI、用户下棋输入、AI生成下一步、计算目数、销毁AI等接口的封装与调用。我们使用了一个专门的线程池来管理AI调用任务，并设置了超时机制来避免阻塞或异常情况。

### 后端 AI 部分

1. 完成了KataGo的编译与docker镜像打包。
2. 设计并编码了Java调用KataGo可执行程序的代码，可以进行KataGo的初始化、退出、落子、预测落子，点目等功能。
3. 完成了一个全新的SpringBoot后端，用于维护多个KataGo进程。
4. 完成了与业务后端部分的通信设计。
5. 完成了容器的部署与运行。

## 二、本轮迭代总结

### 前端

1. 前端的交互逻辑较为复杂，涉及到多个界面之间的数据传递，用户操作的响应，以及异常情况的处理。在编写代码前需要进行详细的设计，明确各个界面的功能，数据结构，以及事件处理方式。同时采用规范的数据存储方法，如使用pinia等状态管理工具，可以更好地完成代码编写任务，避免出现数据混乱，逻辑冲突等问题。
2. 前后端之间的通信是前端开发的重要环节，需要保证数据的正确性，完整性，及时性，以及安全性。为了实现这一目标，需要进行充分的沟通，或者详细的文档，明确各个接口的参数，返回值，错误码，以及业务逻辑。否则会对开发进度造成极大的阻碍，甚至导致功能无法实现，或者出现严重的bug。
3. 前端的视觉设计是前端开发的重要组成部分，直接影响到用户的第一印象，以及用户体验。前端的视觉设计需要较高的审美水平，以及长年累月的经验积累，才能做出符合用户需求，以及符合行业标准的界面。而我们在此方面较为欠缺，因此最终的成品的美观度只能说是差强人意，还有很大的提升空间。

### 后段业务部分

1. 在后端开发过程中，如何调度所有的组员进入开发状态是最大的难点。在项目的初期阶段，由于任务的分配不合理，导致有些模块被多个人进行了不同形式的重写。例如鉴权模块在初期设计时考虑不周，有两位组员重复实现了其中的一部分代码，为后续的合并带来了麻烦。
2. 与前端的协作也是一大难点。初期我们使用腾讯文档进行文档撰写，但是由于文档更新的滞后性导致前端开发进展不顺。后续我们采用Swagger自动生成API文档，并频繁部署，以提升文档更新的及时性。
3. 我们也发现了自己在一些方面还有很多知识盲区，比如分布式系统、微服务架构、缓存技术、消息队列等。这些都是我们之后需要重点学习和掌握的，所以我们在项目中不断地反思和改进，提高了自己的学习意识和进取心。

### 后端 AI 部分

1. Java调用其他可执行程序的代码并不容易管理，不注意时很容易造成系统资源泄露。在本程序设计初期，即经常遭遇AI进程未释放导致的内存溢出问题。
2. 虽然使用docker开发相对于直接在开发机打包jar包上传服务器要多一些工作量，但是在处理环境配置复杂时的情况会大大减轻运维人员的压力。例如本项目的KataGo由于使用了动态链接，对一些动态链接库有着依赖。如果每位开发人员都在本机编译一份KataGo，势必增加后续修改KataGo带来的工作量。
3. 将AI此类重负载任务与业务代码分离，有利于未来业务的拓展，例如增加AI算力可以通过增加多台机器而非更换一台更强劲的机器来实现。
